// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get approvee(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get direction(): i32 {
    return this._event.parameters[3].value.toI32();
  }
}

export class Initialized extends ethereum.Event {
  get params(): Initialized__Params {
    return new Initialized__Params(this);
  }
}

export class Initialized__Params {
  _event: Initialized;

  constructor(event: Initialized) {
    this._event = event;
  }

  get version(): i32 {
    return this._event.parameters[0].value.toI32();
  }
}

export class LiquidityAdded extends ethereum.Event {
  get params(): LiquidityAdded__Params {
    return new LiquidityAdded__Params(this);
  }
}

export class LiquidityAdded__Params {
  _event: LiquidityAdded;

  constructor(event: LiquidityAdded) {
    this._event = event;
  }

  get liquidityProvider(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get liquidityAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get nativeDeposit(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get tokenDeposit(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class LiquidityRemoved extends ethereum.Event {
  get params(): LiquidityRemoved__Params {
    return new LiquidityRemoved__Params(this);
  }
}

export class LiquidityRemoved__Params {
  _event: LiquidityRemoved;

  constructor(event: LiquidityRemoved) {
    this._event = event;
  }

  get liquidityProvider(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get liquidityAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get nativeWithdrawn(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get tokensWithdrawn(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Swap extends ethereum.Event {
  get params(): Swap__Params {
    return new Swap__Params(this);
  }
}

export class Swap__Params {
  _event: Swap;

  constructor(event: Swap) {
    this._event = event;
  }

  get swapee(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get output(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get direction(): i32 {
    return this._event.parameters[3].value.toI32();
  }
}

export class NativeLiquidityPool__getAllowanceOfResultValue0Struct extends ethereum.Tuple {
  get amount(): BigInt {
    return this[0].toBigInt();
  }

  get direction(): i32 {
    return this[1].toI32();
  }
}

export class NativeLiquidityPool extends ethereum.SmartContract {
  static bind(address: Address): NativeLiquidityPool {
    return new NativeLiquidityPool("NativeLiquidityPool", address);
  }

  getAllowanceOf(
    owner: Address,
    allowee: Address
  ): NativeLiquidityPool__getAllowanceOfResultValue0Struct {
    let result = super.call(
      "getAllowanceOf",
      "getAllowanceOf(address,address):((uint256,uint8))",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(allowee)]
    );

    return changetype<NativeLiquidityPool__getAllowanceOfResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_getAllowanceOf(
    owner: Address,
    allowee: Address
  ): ethereum.CallResult<
    NativeLiquidityPool__getAllowanceOfResultValue0Struct
  > {
    let result = super.tryCall(
      "getAllowanceOf",
      "getAllowanceOf(address,address):((uint256,uint8))",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(allowee)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<NativeLiquidityPool__getAllowanceOfResultValue0Struct>(
        value[0].toTuple()
      )
    );
  }

  getEligibleNativeOf(liquidityAmount: BigInt): BigInt {
    let result = super.call(
      "getEligibleNativeOf",
      "getEligibleNativeOf(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(liquidityAmount)]
    );

    return result[0].toBigInt();
  }

  try_getEligibleNativeOf(
    liquidityAmount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getEligibleNativeOf",
      "getEligibleNativeOf(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(liquidityAmount)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getEligibleTokensOf(liquidityAmount: BigInt): BigInt {
    let result = super.call(
      "getEligibleTokensOf",
      "getEligibleTokensOf(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(liquidityAmount)]
    );

    return result[0].toBigInt();
  }

  try_getEligibleTokensOf(
    liquidityAmount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getEligibleTokensOf",
      "getEligibleTokensOf(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(liquidityAmount)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getKind(): i32 {
    let result = super.call("getKind", "getKind():(uint8)", []);

    return result[0].toI32();
  }

  try_getKind(): ethereum.CallResult<i32> {
    let result = super.tryCall("getKind", "getKind():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getLiquidityOf(addr: Address): BigInt {
    let result = super.call(
      "getLiquidityOf",
      "getLiquidityOf(address):(uint256)",
      [ethereum.Value.fromAddress(addr)]
    );

    return result[0].toBigInt();
  }

  try_getLiquidityOf(addr: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLiquidityOf",
      "getLiquidityOf(address):(uint256)",
      [ethereum.Value.fromAddress(addr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getNativeOutputForSwap(tokenAmount: BigInt): BigInt {
    let result = super.call(
      "getNativeOutputForSwap",
      "getNativeOutputForSwap(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(tokenAmount)]
    );

    return result[0].toBigInt();
  }

  try_getNativeOutputForSwap(tokenAmount: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNativeOutputForSwap",
      "getNativeOutputForSwap(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(tokenAmount)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolLiquidity(): BigInt {
    let result = super.call(
      "getPoolLiquidity",
      "getPoolLiquidity():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getPoolLiquidity(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPoolLiquidity",
      "getPoolLiquidity():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTokenAddress(): Address {
    let result = super.call(
      "getTokenAddress",
      "getTokenAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getTokenAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getTokenAddress",
      "getTokenAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getTokenAmountForNativeDeposit(nativeAmount: BigInt): BigInt {
    let result = super.call(
      "getTokenAmountForNativeDeposit",
      "getTokenAmountForNativeDeposit(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(nativeAmount)]
    );

    return result[0].toBigInt();
  }

  try_getTokenAmountForNativeDeposit(
    nativeAmount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTokenAmountForNativeDeposit",
      "getTokenAmountForNativeDeposit(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(nativeAmount)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTokenOutputForSwap(nativeAmount: BigInt): BigInt {
    let result = super.call(
      "getTokenOutputForSwap",
      "getTokenOutputForSwap(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(nativeAmount)]
    );

    return result[0].toBigInt();
  }

  try_getTokenOutputForSwap(nativeAmount: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTokenOutputForSwap",
      "getTokenOutputForSwap(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(nativeAmount)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get tokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get swapFee(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get approvee(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get direction(): i32 {
    return this._call.inputValues[2].value.toI32();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get tokenDeposit(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class ProvideLiquidityCall extends ethereum.Call {
  get inputs(): ProvideLiquidityCall__Inputs {
    return new ProvideLiquidityCall__Inputs(this);
  }

  get outputs(): ProvideLiquidityCall__Outputs {
    return new ProvideLiquidityCall__Outputs(this);
  }
}

export class ProvideLiquidityCall__Inputs {
  _call: ProvideLiquidityCall;

  constructor(call: ProvideLiquidityCall) {
    this._call = call;
  }
}

export class ProvideLiquidityCall__Outputs {
  _call: ProvideLiquidityCall;

  constructor(call: ProvideLiquidityCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SwapCall extends ethereum.Call {
  get inputs(): SwapCall__Inputs {
    return new SwapCall__Inputs(this);
  }

  get outputs(): SwapCall__Outputs {
    return new SwapCall__Outputs(this);
  }
}

export class SwapCall__Inputs {
  _call: SwapCall;

  constructor(call: SwapCall) {
    this._call = call;
  }

  get tokenAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get direction(): i32 {
    return this._call.inputValues[1].value.toI32();
  }
}

export class SwapCall__Outputs {
  _call: SwapCall;

  constructor(call: SwapCall) {
    this._call = call;
  }
}

export class SwapFromCall extends ethereum.Call {
  get inputs(): SwapFromCall__Inputs {
    return new SwapFromCall__Inputs(this);
  }

  get outputs(): SwapFromCall__Outputs {
    return new SwapFromCall__Outputs(this);
  }
}

export class SwapFromCall__Inputs {
  _call: SwapFromCall;

  constructor(call: SwapFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SwapFromCall__Outputs {
  _call: SwapFromCall;

  constructor(call: SwapFromCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawLiquidityCall extends ethereum.Call {
  get inputs(): WithdrawLiquidityCall__Inputs {
    return new WithdrawLiquidityCall__Inputs(this);
  }

  get outputs(): WithdrawLiquidityCall__Outputs {
    return new WithdrawLiquidityCall__Outputs(this);
  }
}

export class WithdrawLiquidityCall__Inputs {
  _call: WithdrawLiquidityCall;

  constructor(call: WithdrawLiquidityCall) {
    this._call = call;
  }

  get liquidityAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class WithdrawLiquidityCall__Outputs {
  _call: WithdrawLiquidityCall;

  constructor(call: WithdrawLiquidityCall) {
    this._call = call;
  }
}
